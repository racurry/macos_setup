{
  "Main Guard": {
    "prefix": "main",
    "body": ["if __name__ == \"__main__\":", "\t${1:main()}"],
    "description": "if __name__ == '__main__' guard"
  },
  "Main with Function": {
    "prefix": "mainf",
    "body": ["def main() -> None:", "\t$0", "", "", "if __name__ == \"__main__\":", "\tmain()"],
    "description": "Main function with guard"
  },
  "Shebang": {
    "prefix": "shebang",
    "body": "#!/usr/bin/env python3",
    "description": "Python shebang"
  },
  "Script Header": {
    "prefix": "header",
    "body": ["#!/usr/bin/env python3", "\"\"\"${1:Module description}.\"\"\"", "", "$0"],
    "description": "Script header with docstring"
  },
  "UV Script Header": {
    "prefix": "uv",
    "body": ["#!/usr/bin/env -S uv run --script", "# /// script", "# requires-python = \">=${1:3.12}\"", "# dependencies = [", "#     \"${2:package}\",", "# ]", "# ///", "", "$0"],
    "description": "UV inline script metadata (PEP 723)"
  },
  "Import": {
    "prefix": "imp",
    "body": "import ${1:module}",
    "description": "Import statement"
  },
  "Import From": {
    "prefix": "from",
    "body": "from ${1:module} import ${2:name}",
    "description": "From import statement"
  },
  "Import Typing": {
    "prefix": "impt",
    "body": "from typing import ${1|Any,Optional,List,Dict,Tuple,Callable,TypeVar,Generic|}",
    "description": "Import from typing"
  },
  "Import Path": {
    "prefix": "imppath",
    "body": "from pathlib import Path",
    "description": "Import Path"
  },
  "Function": {
    "prefix": "def",
    "body": ["def ${1:function_name}(${2:params}) -> ${3:None}:", "\t\"\"\"${4:Docstring}.\"\"\"", "\t$0"],
    "description": "Function with type hints and docstring"
  },
  "Async Function": {
    "prefix": "adef",
    "body": ["async def ${1:function_name}(${2:params}) -> ${3:None}:", "\t\"\"\"${4:Docstring}.\"\"\"", "\t$0"],
    "description": "Async function with type hints"
  },
  "Method": {
    "prefix": "method",
    "body": ["def ${1:method_name}(self${2:, params}) -> ${3:None}:", "\t\"\"\"${4:Docstring}.\"\"\"", "\t$0"],
    "description": "Method with type hints"
  },
  "Class": {
    "prefix": "class",
    "body": ["class ${1:ClassName}:", "\t\"\"\"${2:Class description}.\"\"\"", "", "\tdef __init__(self${3:, params}) -> None:", "\t\t\"\"\"Initialize ${1:ClassName}.\"\"\"", "\t\t$0"],
    "description": "Class with docstring and init"
  },
  "Dataclass": {
    "prefix": "dataclass",
    "body": ["from dataclasses import dataclass", "", "", "@dataclass", "class ${1:ClassName}:", "\t\"\"\"${2:Description}.\"\"\"", "", "\t${3:field}: ${4:str}", "\t$0"],
    "description": "Dataclass"
  },
  "Dataclass Frozen": {
    "prefix": "dataclassf",
    "body": ["@dataclass(frozen=True)", "class ${1:ClassName}:", "\t\"\"\"${2:Description}.\"\"\"", "", "\t${3:field}: ${4:str}"],
    "description": "Frozen dataclass"
  },
  "Property": {
    "prefix": "prop",
    "body": ["@property", "def ${1:name}(self) -> ${2:type}:", "\t\"\"\"${3:Description}.\"\"\"", "\treturn self._${1:name}"],
    "description": "Property getter"
  },
  "Docstring": {
    "prefix": "doc",
    "body": ["\"\"\"${1:Summary}.", "", "Args:", "\t${2:param}: ${3:Description}.", "", "Returns:", "\t${4:Description}.", "\"\"\""],
    "description": "Google-style docstring"
  },
  "Docstring Simple": {
    "prefix": "docs",
    "body": "\"\"\"${1:Description}.\"\"\"",
    "description": "One-line docstring"
  },
  "Try Except": {
    "prefix": "try",
    "body": ["try:", "\t$1", "except ${2:Exception} as e:", "\t${3:raise}"],
    "description": "Try-except block"
  },
  "Try Except Finally": {
    "prefix": "tryf",
    "body": ["try:", "\t$1", "except ${2:Exception} as e:", "\t${3:raise}", "finally:", "\t$0"],
    "description": "Try-except-finally block"
  },
  "Context Manager": {
    "prefix": "with",
    "body": ["with ${1:open(\"file\")} as ${2:f}:", "\t$0"],
    "description": "With statement"
  },
  "Open File Read": {
    "prefix": "openr",
    "body": ["with open(${1:path}, \"r\") as f:", "\t${2:content} = f.read()", "\t$0"],
    "description": "Open file for reading"
  },
  "Open File Write": {
    "prefix": "openw",
    "body": ["with open(${1:path}, \"w\") as f:", "\tf.write($0)"],
    "description": "Open file for writing"
  },
  "Path Read": {
    "prefix": "pathread",
    "body": "${1:content} = Path(${2:path}).read_text()",
    "description": "Read file with pathlib"
  },
  "Path Write": {
    "prefix": "pathwrite",
    "body": "Path(${1:path}).write_text(${2:content})",
    "description": "Write file with pathlib"
  },
  "List Comprehension": {
    "prefix": "lc",
    "body": "[${1:x} for ${2:x} in ${3:iterable}]",
    "description": "List comprehension"
  },
  "Dict Comprehension": {
    "prefix": "dc",
    "body": "{${1:k}: ${2:v} for ${3:k}, ${4:v} in ${5:items}}",
    "description": "Dict comprehension"
  },
  "Lambda": {
    "prefix": "lam",
    "body": "lambda ${1:x}: ${2:x}",
    "description": "Lambda function"
  },
  "Print Debug": {
    "prefix": "pp",
    "body": "print(f\"${1:var}={${1:var}!r}\")",
    "description": "Print variable with name"
  },
  "Breakpoint": {
    "prefix": "bp",
    "body": "breakpoint()",
    "description": "Breakpoint (Python 3.7+)"
  },
  "PDB": {
    "prefix": "pdb",
    "body": "import pdb; pdb.set_trace()",
    "description": "PDB breakpoint (legacy)"
  },
  "TODO": {
    "prefix": "todo",
    "body": "# TODO: $0",
    "description": "TODO comment"
  },
  "FIXME": {
    "prefix": "fixme",
    "body": "# FIXME: $0",
    "description": "FIXME comment"
  },
  "Logger": {
    "prefix": "logger",
    "body": ["import logging", "", "logger = logging.getLogger(__name__)"],
    "description": "Setup logger"
  },
  "Log Debug": {
    "prefix": "logd",
    "body": "logger.debug(f\"$0\")",
    "description": "Debug log"
  },
  "Log Info": {
    "prefix": "logi",
    "body": "logger.info(f\"$0\")",
    "description": "Info log"
  },
  "Log Error": {
    "prefix": "loge",
    "body": "logger.error(f\"$0\")",
    "description": "Error log"
  },
  "Assert": {
    "prefix": "ass",
    "body": "assert ${1:condition}, \"${2:message}\"",
    "description": "Assert with message"
  },
  "Raise": {
    "prefix": "raise",
    "body": "raise ${1|ValueError,TypeError,RuntimeError,NotImplementedError|}(\"${2:message}\")",
    "description": "Raise exception"
  },
  "Type Alias": {
    "prefix": "alias",
    "body": "type ${1:Name} = ${2:str}",
    "description": "Type alias (Python 3.12+)"
  },
  "TypeVar": {
    "prefix": "typevar",
    "body": "${1:T} = TypeVar(\"${1:T}\")",
    "description": "TypeVar"
  },
  "Enum": {
    "prefix": "enum",
    "body": ["from enum import Enum, auto", "", "", "class ${1:Name}(Enum):", "\t${2:VALUE} = auto()", "\t$0"],
    "description": "Enum class"
  },
  "NamedTuple": {
    "prefix": "namedtuple",
    "body": ["from typing import NamedTuple", "", "", "class ${1:Name}(NamedTuple):", "\t${2:field}: ${3:str}", "\t$0"],
    "description": "NamedTuple class"
  },
  "Pytest Test": {
    "prefix": "test",
    "body": ["def test_${1:name}() -> None:", "\t\"\"\"Test ${2:description}.\"\"\"", "\t$0"],
    "description": "Pytest test function"
  },
  "Pytest Fixture": {
    "prefix": "fixture",
    "body": ["@pytest.fixture", "def ${1:name}() -> ${2:type}:", "\t\"\"\"${3:Description}.\"\"\"", "\t$0"],
    "description": "Pytest fixture"
  }
}
