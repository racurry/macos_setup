#!/bin/bash
set -euo pipefail

# gh-pr - Manage your GitHub pull requests
#
# Shows status of all your open PRs across repositories.
# Optionally updates them by rebasing on their base branch.

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Options
DO_UPDATE=false
INCLUDE_DRAFTS=false
REPO=""
ORG=""

show_help() {
    cat <<EOF
Usage: gh-pr [OPTIONS]

Show status of all your open PRs on GitHub. Optionally rebase them with their base branch.

Options:
    --update            Rebase PRs that are behind their base branch
    --repo OWNER/REPO   Limit to specific repository
    --org ORG           Limit to an organization or user (e.g., galileo-inc, racurry)
    --include-drafts    Include draft PRs (excluded by default)
    -h, --help          Show this help message

Examples:
    gh-pr                           # Show status of all your open PRs
    gh-pr --update                  # Rebase PRs that are behind
    gh-pr --org galileo-inc         # Only PRs in galileo-inc repos
    gh-pr --repo cli/cli            # Only PRs in cli/cli repo
    gh-pr --update --include-drafts # Update including draft PRs

Merge State Reference:
    BEHIND      PR branch is behind base - can be updated with --update
    CLEAN       Already up to date with base
    DIRTY       Has merge conflicts - requires manual resolution
    BLOCKED     Blocked by branch protection rules
    UNKNOWN     GitHub still computing status

Requirements:
    - gh CLI installed and authenticated
    - jq installed for JSON parsing
EOF
}

log_info() { echo -e "${BLUE}ℹ${NC} $*"; }
log_success() { echo -e "${GREEN}✓${NC} $*"; }
log_warn() { echo -e "${YELLOW}⚠${NC} $*"; }
log_error() { echo -e "${RED}✗${NC} $*"; }

check_requirements() {
    local missing=()

    if ! command -v gh &> /dev/null; then
        missing+=("gh CLI (https://cli.github.com/)")
    fi

    if ! command -v jq &> /dev/null; then
        missing+=("jq (brew install jq)")
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing required tools:"
        for tool in "${missing[@]}"; do
            echo "  - $tool"
        done
        exit 1
    fi

    if ! gh auth status &> /dev/null 2>&1; then
        log_error "gh CLI is not authenticated. Run: gh auth login"
        exit 1
    fi
}

get_open_prs() {
    local prs_json

    # Build query args array - terms must be separate arguments, not quoted together
    local query_args=()
    [[ "$INCLUDE_DRAFTS" == false ]] && query_args+=(draft:false)

    if [[ -n "$REPO" ]]; then
        # Single repo - use gh pr list (more efficient, better fields)
        local draft_arg=()
        [[ "$INCLUDE_DRAFTS" == false ]] && draft_arg=(--draft false)

        prs_json=$(gh pr list --author @me --state open --repo "$REPO" \
            "${draft_arg[@]}" \
            --json number,title,url,baseRefName,headRefName 2>/dev/null) || prs_json="[]"

        # Add repo field for consistent processing
        echo "$prs_json" | jq --arg repo "$REPO" '[.[] | . + {repo: $repo}]'
    elif [[ -n "$ORG" ]]; then
        # Filter by org/user - use gh search with org: qualifier
        query_args+=("org:${ORG}")

        prs_json=$(gh search prs --author @me --state open --limit 100 \
            "${query_args[@]}" --json number,title,url,repository 2>/dev/null) || prs_json="[]"

        # Restructure to extract repo name
        echo "$prs_json" | jq '[.[] | {number, title, url, repo: .repository.nameWithOwner}]'
    else
        # All repos - use gh search prs
        prs_json=$(gh search prs --author @me --state open --limit 100 \
            "${query_args[@]}" --json number,title,url,repository 2>/dev/null) || prs_json="[]"

        # Restructure to extract repo name
        echo "$prs_json" | jq '[.[] | {number, title, url, repo: .repository.nameWithOwner}]'
    fi
}

get_pr_status() {
    local repo=$1
    local number=$2

    gh pr view "$number" --repo "$repo" \
        --json mergeStateStatus,baseRefName,headRefName,isDraft,statusCheckRollup 2>/dev/null || echo "{}"
}

# Summarize check status from statusCheckRollup array
summarize_checks() {
    local status_json=$1
    local checks
    checks=$(echo "$status_json" | jq -r '.statusCheckRollup // []')

    local total passing failing pending
    total=$(echo "$checks" | jq 'length')

    if [[ "$total" -eq 0 ]]; then
        echo "none"
        return
    fi

    passing=$(echo "$checks" | jq '[.[] | select(.conclusion == "SUCCESS" or .state == "SUCCESS")] | length')
    failing=$(echo "$checks" | jq '[.[] | select(.conclusion == "FAILURE" or .state == "FAILURE" or .conclusion == "ERROR" or .state == "ERROR")] | length')
    pending=$(echo "$checks" | jq '[.[] | select(.state == "PENDING" or .conclusion == null or .conclusion == "")] | length')

    if [[ "$failing" -gt 0 ]]; then
        echo "failing:${failing}/${total}"
    elif [[ "$pending" -gt 0 ]]; then
        echo "pending:${pending}/${total}"
    else
        echo "passing:${total}/${total}"
    fi
}

update_pr() {
    local repo=$1
    local number=$2

    gh pr update-branch "$number" --repo "$repo" --rebase 2>&1
}

# Process a single PR and return status code:
# 0 = updated, 1 = up-to-date, 2 = skipped, 3 = failed
process_pr() {
    local repo=$1
    local number=$2
    local title=$3
    local url=$4

    echo ""
    echo -e "${CYAN}${BOLD}PR #${number}${NC} - ${title}"
    echo -e "  ${BLUE}${url}${NC}"
    echo -e "  Repo: ${YELLOW}${repo}${NC}"

    # Get PR status
    local status_json
    status_json=$(get_pr_status "$repo" "$number")

    if [[ -z "$status_json" || "$status_json" == "{}" ]]; then
        log_error "  Could not fetch PR status"
        return 3
    fi

    local merge_state base_ref is_draft check_summary
    merge_state=$(echo "$status_json" | jq -r '.mergeStateStatus // "UNKNOWN"')
    base_ref=$(echo "$status_json" | jq -r '.baseRefName // "unknown"')
    is_draft=$(echo "$status_json" | jq -r '.isDraft // false')
    check_summary=$(summarize_checks "$status_json")

    local draft_indicator=""
    [[ "$is_draft" == "true" ]] && draft_indicator=" ${YELLOW}[DRAFT]${NC}"

    # Format check status with color
    local check_display
    case "${check_summary%%:*}" in
        failing)
            check_display="${RED}${check_summary#*:} failing${NC}"
            ;;
        pending)
            check_display="${YELLOW}${check_summary#*:} pending${NC}"
            ;;
        passing)
            check_display="${GREEN}${check_summary#*:} passing${NC}"
            ;;
        none)
            check_display="${BLUE}no checks${NC}"
            ;;
    esac

    echo -e "  Base: ${YELLOW}${base_ref}${NC} | Status: ${YELLOW}${merge_state}${NC} | Checks: ${check_display}${draft_indicator}"

    # Determine if we should attempt update
    # BEHIND = definitely needs update
    # BLOCKED = might need update (branch protection doesn't tell us if behind)
    # CLEAN = already up to date
    # DIRTY = has conflicts, can't auto-update
    local should_update=false
    local skip_reason=""

    case "$merge_state" in
        BEHIND)
            should_update=true
            ;;
        BLOCKED)
            # BLOCKED means can't merge due to branch protection, but may still be behind
            # Attempt the update - gh will tell us if already up to date
            should_update=true
            ;;
        CLEAN|HAS_HOOKS|UNSTABLE)
            log_success "  Already up to date"
            return 1
            ;;
        DIRTY)
            skip_reason="Has merge conflicts - manual resolution required"
            ;;
        UNKNOWN)
            # Try anyway - GitHub might still be computing
            should_update=true
            ;;
        *)
            skip_reason="Unexpected status: ${merge_state}"
            ;;
    esac

    if [[ -n "$skip_reason" ]]; then
        log_warn "  ${skip_reason}"
        return 2
    fi

    if [[ "$should_update" == true ]]; then
        if [[ "$DO_UPDATE" == false ]]; then
            log_warn "  Behind ${base_ref} (use --update to rebase)"
            return 2
        fi

        log_info "  Rebasing on ${base_ref}..."
        local result
        if result=$(update_pr "$repo" "$number" 2>&1); then
            # Check if it was actually updated or already up to date
            if [[ "$result" == *"already up to date"* ]] || [[ "$result" == *"Already up to date"* ]]; then
                log_success "  Already up to date"
                return 1
            else
                log_success "  Updated successfully"
                return 0
            fi
        else
            log_error "  Failed to update: $result"
            return 3
        fi
    fi
}

main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help|help)
                show_help
                exit 0
                ;;
            --update)
                DO_UPDATE=true
                shift
                ;;
            --include-drafts)
                INCLUDE_DRAFTS=true
                shift
                ;;
            --repo)
                if [[ -z "${2:-}" ]]; then
                    log_error "--repo requires an argument (OWNER/REPO)"
                    exit 1
                fi
                REPO="$2"
                shift 2
                ;;
            --org)
                if [[ -z "${2:-}" ]]; then
                    log_error "--org requires an argument (ORG)"
                    exit 1
                fi
                ORG="$2"
                shift 2
                ;;
            *)
                log_error "Unknown option: $1"
                echo ""
                show_help
                exit 1
                ;;
        esac
    done

    # Validate mutually exclusive options
    if [[ -n "$REPO" && -n "$ORG" ]]; then
        log_error "--repo and --org are mutually exclusive"
        exit 1
    fi

    check_requirements

    echo -e "${BOLD}Finding your open PRs...${NC}"
    if [[ -n "$REPO" ]]; then
        echo -e "  Filtering to repo: ${CYAN}${REPO}${NC}"
    elif [[ -n "$ORG" ]]; then
        echo -e "  Filtering to org: ${CYAN}${ORG}${NC}"
    else
        echo -e "  Searching all repositories"
    fi

    local prs_json
    prs_json=$(get_open_prs)

    local pr_count
    pr_count=$(echo "$prs_json" | jq 'length')

    if [[ "$pr_count" -eq 0 ]]; then
        log_info "No open PRs found"
        exit 0
    fi

    echo -e "Found ${BOLD}${pr_count}${NC} open PR(s)"

    # Counters
    local updated=0 up_to_date=0 skipped=0 failed=0

    # Read PRs into array to avoid subshell counter issues
    local pr_entries=()
    while IFS= read -r pr; do
        pr_entries+=("$pr")
    done < <(echo "$prs_json" | jq -c '.[]')

    # Process each PR
    for pr in "${pr_entries[@]}"; do
        local repo number title url
        repo=$(echo "$pr" | jq -r '.repo')
        number=$(echo "$pr" | jq -r '.number')
        title=$(echo "$pr" | jq -r '.title')
        url=$(echo "$pr" | jq -r '.url')

        local result=0
        process_pr "$repo" "$number" "$title" "$url" || result=$?

        case $result in
            0) ((updated++)) ;;
            1) ((up_to_date++)) ;;
            2) ((skipped++)) ;;
            3) ((failed++)) ;;
        esac
    done

    # Summary
    echo ""
    echo -e "${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}Summary${NC}"
    echo -e "${BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    [[ $updated -gt 0 ]] && echo -e "  ${GREEN}✓ Updated:${NC}        $updated"
    [[ $up_to_date -gt 0 ]] && echo -e "  ${GREEN}✓ Up to date:${NC}     $up_to_date"
    [[ $skipped -gt 0 ]] && echo -e "  ${YELLOW}⚠ Skipped:${NC}        $skipped"
    [[ $failed -gt 0 ]] && echo -e "  ${RED}✗ Failed:${NC}         $failed"

    # Exit with error if any failures
    [[ $failed -gt 0 ]] && exit 1
    exit 0
}

main "$@"
