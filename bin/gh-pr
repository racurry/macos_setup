#!/bin/bash
set -euo pipefail

# gh-pr - Manage your GitHub pull requests
#
# Shows status of all your open PRs across repositories.
# Optionally updates them by rebasing on their base branch.

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Options
DO_UPDATE=false
INCLUDE_DRAFTS=false
REPO=""
ORG=""

show_help() {
    cat <<EOF
Usage: gh-pr [OPTIONS]

Show status of all your open PRs on GitHub. Optionally rebase them with their base branch.

Options:
    --update            Rebase PRs that are behind their base branch
    --repo OWNER/REPO   Limit to specific repository
    --org ORG           Limit to an organization or user (e.g., galileo-inc, racurry)
    --include-drafts    Include draft PRs (excluded by default)
    -h, --help          Show this help message

Examples:
    gh-pr                           # Show status of all your open PRs
    gh-pr --update                  # Rebase PRs that are behind
    gh-pr --org galileo-inc         # Only PRs in galileo-inc repos
    gh-pr --repo cli/cli            # Only PRs in cli/cli repo
    gh-pr --update --include-drafts # Update including draft PRs

Merge State Reference:
    BEHIND      PR branch is behind base - can be updated with --update
    CLEAN       Already up to date with base
    DIRTY       Has merge conflicts - requires manual resolution
    BLOCKED     Blocked by branch protection rules
    UNKNOWN     GitHub still computing status

Requirements:
    - gh CLI installed and authenticated
    - jq installed for JSON parsing
EOF
}

log_info() { echo -e "${BLUE}ℹ${NC} $*"; }
log_success() { echo -e "${GREEN}✓${NC} $*"; }
log_warn() { echo -e "${YELLOW}⚠${NC} $*"; }
log_error() { echo -e "${RED}✗${NC} $*"; }

check_requirements() {
    local missing=()

    if ! command -v gh &> /dev/null; then
        missing+=("gh CLI (https://cli.github.com/)")
    fi

    if ! command -v jq &> /dev/null; then
        missing+=("jq (brew install jq)")
    fi

    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing required tools:"
        for tool in "${missing[@]}"; do
            echo "  - $tool"
        done
        exit 1
    fi

    if ! gh auth status &> /dev/null 2>&1; then
        log_error "gh CLI is not authenticated. Run: gh auth login"
        exit 1
    fi
}

get_open_prs() {
    local prs_json

    # Build query args array - terms must be separate arguments, not quoted together
    local query_args=()
    [[ "$INCLUDE_DRAFTS" == false ]] && query_args+=(draft:false)

    if [[ -n "$REPO" ]]; then
        # Single repo - use gh pr list (more efficient, better fields)
        local draft_arg=()
        [[ "$INCLUDE_DRAFTS" == false ]] && draft_arg=(--draft false)

        prs_json=$(gh pr list --author @me --state open --repo "$REPO" \
            "${draft_arg[@]}" \
            --json number,title,url,baseRefName,headRefName 2>/dev/null) || prs_json="[]"

        # Add repo field for consistent processing
        echo "$prs_json" | jq --arg repo "$REPO" '[.[] | . + {repo: $repo}]'
    elif [[ -n "$ORG" ]]; then
        # Filter by org/user - use gh search with org: qualifier
        query_args+=("org:${ORG}")

        prs_json=$(gh search prs --author @me --state open --limit 100 \
            "${query_args[@]}" --json number,title,url,repository 2>/dev/null) || prs_json="[]"

        # Restructure to extract repo name
        echo "$prs_json" | jq '[.[] | {number, title, url, repo: .repository.nameWithOwner}]'
    else
        # All repos - use gh search prs
        prs_json=$(gh search prs --author @me --state open --limit 100 \
            "${query_args[@]}" --json number,title,url,repository 2>/dev/null) || prs_json="[]"

        # Restructure to extract repo name
        echo "$prs_json" | jq '[.[] | {number, title, url, repo: .repository.nameWithOwner}]'
    fi
}

get_pr_status() {
    local repo=$1
    local number=$2

    gh pr view "$number" --repo "$repo" \
        --json mergeStateStatus,baseRefName,headRefName,isDraft,statusCheckRollup 2>/dev/null || echo "{}"
}

# Summarize check status from statusCheckRollup array
summarize_checks() {
    local status_json=$1
    local checks
    checks=$(echo "$status_json" | jq -r '.statusCheckRollup // []')

    local total passing failing pending
    total=$(echo "$checks" | jq 'length')

    if [[ "$total" -eq 0 ]]; then
        echo "none"
        return
    fi

    passing=$(echo "$checks" | jq '[.[] | select(.conclusion == "SUCCESS" or .state == "SUCCESS")] | length')
    failing=$(echo "$checks" | jq '[.[] | select(.conclusion == "FAILURE" or .state == "FAILURE" or .conclusion == "ERROR" or .state == "ERROR")] | length')
    pending=$(echo "$checks" | jq '[.[] | select(.state == "PENDING" or .conclusion == null or .conclusion == "")] | length')

    if [[ "$failing" -gt 0 ]]; then
        echo "failing:${failing}/${total}"
    elif [[ "$pending" -gt 0 ]]; then
        echo "pending:${pending}/${total}"
    else
        echo "passing:${total}/${total}"
    fi
}

update_pr() {
    local repo=$1
    local number=$2

    gh pr update-branch "$number" --repo "$repo" --rebase 2>&1
}

# Process a single PR and return status code:
# 0 = updated, 1 = up-to-date, 2 = skipped/behind, 3 = failed
process_pr() {
    local repo=$1
    local number=$2
    local title=$3
    local url=$4

    echo -e "  ${CYAN}${BOLD}PR #${number}${NC} - ${title}"
    echo -e "  ${BLUE}${url}${NC}"

    # Get PR status
    local status_json
    status_json=$(get_pr_status "$repo" "$number")

    if [[ -z "$status_json" || "$status_json" == "{}" ]]; then
        echo -e "  ${RED}Could not fetch PR status${NC}"
        echo ""
        return 3
    fi

    local merge_state is_draft check_summary
    merge_state=$(echo "$status_json" | jq -r '.mergeStateStatus // "UNKNOWN"')
    is_draft=$(echo "$status_json" | jq -r '.isDraft // false')
    check_summary=$(summarize_checks "$status_json")

    local draft_indicator=""
    [[ "$is_draft" == "true" ]] && draft_indicator=" ${YELLOW}[DRAFT]${NC}"

    # Format check status with color
    local check_display
    case "${check_summary%%:*}" in
        failing)
            check_display="${RED}${check_summary#*:} failing${NC}"
            ;;
        pending)
            check_display="${YELLOW}${check_summary#*:} pending${NC}"
            ;;
        passing)
            check_display="${GREEN}${check_summary#*:} passing${NC}"
            ;;
        none)
            check_display="${BLUE}no checks${NC}"
            ;;
    esac

    # Determine status indicator and whether to update
    local status_indicator=""
    local should_update=false

    case "$merge_state" in
        BEHIND)
            status_indicator=" | ${YELLOW}OUTDATED${NC}"
            should_update=true
            ;;
        BLOCKED)
            # BLOCKED means can't merge due to branch protection, but may still be behind
            status_indicator=" | ${YELLOW}OUTDATED${NC}"
            should_update=true
            ;;
        CLEAN|HAS_HOOKS|UNSTABLE)
            # Up to date, no indicator needed
            ;;
        DIRTY)
            status_indicator=" | ${RED}CONFLICTS${NC}"
            ;;
        UNKNOWN)
            status_indicator=" | ${YELLOW}UNKNOWN${NC}"
            should_update=true
            ;;
        *)
            status_indicator=" | ${RED}${merge_state}${NC}"
            ;;
    esac

    echo -e "  Status: ${YELLOW}${merge_state}${NC} | Checks: ${check_display}${status_indicator}${draft_indicator}"
    echo ""

    # Handle update if requested
    if [[ "$should_update" == true && "$DO_UPDATE" == true ]]; then
        echo -e "  ${BLUE}ℹ${NC} Rebasing..."
        local result
        if result=$(update_pr "$repo" "$number" 2>&1); then
            if [[ "$result" == *"already up to date"* ]] || [[ "$result" == *"Already up to date"* ]]; then
                echo -e "  ${GREEN}✓${NC} Already up to date"
                return 1
            else
                echo -e "  ${GREEN}✓${NC} Updated successfully"
                return 0
            fi
        else
            echo -e "  ${RED}✗${NC} Failed to update: $result"
            return 3
        fi
    fi

    # Return codes for non-update mode
    case "$merge_state" in
        CLEAN|HAS_HOOKS|UNSTABLE) return 1 ;;  # up-to-date
        DIRTY) return 2 ;;  # conflicts
        *) return 2 ;;  # behind/other
    esac
}

main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help|help)
                show_help
                exit 0
                ;;
            --update)
                DO_UPDATE=true
                shift
                ;;
            --include-drafts)
                INCLUDE_DRAFTS=true
                shift
                ;;
            --repo)
                if [[ -z "${2:-}" ]]; then
                    log_error "--repo requires an argument (OWNER/REPO)"
                    exit 1
                fi
                REPO="$2"
                shift 2
                ;;
            --org)
                if [[ -z "${2:-}" ]]; then
                    log_error "--org requires an argument (ORG)"
                    exit 1
                fi
                ORG="$2"
                shift 2
                ;;
            *)
                log_error "Unknown option: $1"
                echo ""
                show_help
                exit 1
                ;;
        esac
    done

    # Validate mutually exclusive options
    if [[ -n "$REPO" && -n "$ORG" ]]; then
        log_error "--repo and --org are mutually exclusive"
        exit 1
    fi

    check_requirements

    echo -e "${BOLD}Finding your open PRs...${NC}"
    if [[ -n "$REPO" ]]; then
        echo -e "  Filtering to repo: ${CYAN}${REPO}${NC}"
    elif [[ -n "$ORG" ]]; then
        echo -e "  Filtering to org: ${CYAN}${ORG}${NC}"
    else
        echo -e "  Searching all repositories"
    fi

    local prs_json
    prs_json=$(get_open_prs)

    local pr_count
    pr_count=$(echo "$prs_json" | jq 'length')

    if [[ "$pr_count" -eq 0 ]]; then
        log_info "No open PRs found"
        exit 0
    fi

    echo -e "Found ${BOLD}${pr_count}${NC} open PR(s)"

    # Group PRs by repo and process
    local repos
    repos=$(echo "$prs_json" | jq -r '[.[].repo] | unique | .[]')

    local had_failures=false

    while IFS= read -r repo; do
        [[ -z "$repo" ]] && continue

        echo ""
        echo -e "${BOLD}Repo: ${YELLOW}${repo}${NC}"

        # Get PRs for this repo
        local repo_prs
        repo_prs=$(echo "$prs_json" | jq -c --arg repo "$repo" '[.[] | select(.repo == $repo)] | .[]')

        while IFS= read -r pr; do
            [[ -z "$pr" ]] && continue

            local number title url
            number=$(echo "$pr" | jq -r '.number')
            title=$(echo "$pr" | jq -r '.title')
            url=$(echo "$pr" | jq -r '.url')

            local result=0
            process_pr "$repo" "$number" "$title" "$url" || result=$?

            [[ $result -eq 3 ]] && had_failures=true
        done <<< "$repo_prs"
    done <<< "$repos"

    # Exit with error if any failures
    [[ "$had_failures" == true ]] && exit 1
    exit 0
}

main "$@"
